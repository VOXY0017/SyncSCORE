{
  "entities": {
    "Player": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Player",
      "type": "object",
      "description": "Represents a player in the ScoreSync application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Player entity."
        },
        "name": {
          "type": "string",
          "description": "The name of the player."
        },
        "score": {
          "type": "number",
          "description": "The player's current score."
        }
      },
      "required": [
        "id",
        "name",
        "score"
      ]
    }
  },
  "auth": {
    "providers": []
  },
  "firestore": {
    "structure": [
      {
        "path": "/players/{playerId}",
        "definition": {
          "entityName": "Player",
          "schema": {
            "$ref": "#/backend/entities/Player"
          },
          "description": "Stores individual player data. Includes 'name' (string), 'score' (number).",
          "params": [
            {
              "name": "playerId",
              "description": "Unique identifier for each player document."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to support a real-time, multi-player score system (ScoreSync). It prioritizes simplicity, real-time updates, and secure data access.  The design achieves Authorization Independence by storing all Player data within the `players` collection, ensuring that no document relies on data outside of itself for authorization. This eliminates the need for `get()` calls in security rules. The structure supports required QAPs by enabling efficient listing and ordering of players based on score. Segregation is achieved as only 'Player' entities exist in the `players` collection, guaranteeing all documents share the same security posture. Because of the nature of the application requirements, a membership map is unecessary, as each player is independent, and no collaboration occurs. Offline support will be handled at the application level, Firebase automatically handles synchronization when connectivity is restored. Firebase listeners are used to provide Real-Time Ranking Updates. Naming is descriptive and consistent."
  }
}
